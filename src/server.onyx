
use core {net, io, string, conv, random, alloc, os, stdio}
use core {tprintf, printf, __flush_stdio}
use json_rpc

port := 0;

comm_socket: net.Socket;
comm_reader: io.Reader;
comm_writer: io.Writer;
json_rpc_handler: json_rpc.Context;

lsp_logger: LspLogger;

setup_jsonrpc :: () {
    use main { MAIN_PKG :: package }

    json_rpc_handler = json_rpc.handler();

    json_rpc_handler->set_metadata("onyx-lsp", "Onyx Language Server", "0.0.1");
    json_rpc_handler->collect_methods(.[MAIN_PKG]);
    json_rpc_handler->enable_openrpc_discovery();
}

process_incoming_message :: () {
    length := 0;
    while true {
        line := comm_reader->read_line(consume_newline=true);
        defer delete(&line);

        if line == "" do return;
        if line == "\r\n" do break;

        key, value := string.bisect(line, #char ":");
        switch string.to_lowercase(key) {
            case "content-length" {
                length = ~~(value
                      |> string.strip_whitespace()
                      |> conv.parse_int());
            }

            case "content-type" ---

            case #default do assert(false, "Unknown header");
        }
    }

    if length == 0 do return;

    message := make([] u8, length);
    defer delete(^message);

    err := comm_reader->read_fill_buffer(message);
    assert(err == .None, "Failed to fill buffer, client was dumb. Dying now.");

    log(.Debug, message);
    if string.empty(message) {
        comm_reader.done = false;
        return;
    }

    json_rpc_handler->handle(message);
}

listen_loop :: () {
    while !comm_reader.done {
        alloc.clear_temp_allocator();
        log(.Debug, "=======================================\n    ... Waiting for next message...\n=======================================");

        //
        // For some reason, there is a non-zero chance that we enter an infinite
        // expensive loop when the host process closes the pipe for standard input.
        // This appears to help, but I have not solved the root cause of the issue.
        io.reader_reset(&comm_reader);

        if port > 0 {
            change := comm_socket->poll();

            if change == .Closed {
                break;
            }

            if change == .Readable {
                while #bottom_test io.reader_get_buffered(^comm_reader) != 0 {
                    process_incoming_message();
                }
            }

        } else {
            process_incoming_message();
        }
    }

    log(.Debug, "Cleaning exiting...");
}

main :: (args) => {
    random.set_seed(os.time());

    if args.count > 0 && string.starts_with(args[0] |> string.as_str(), "init") {
        for os.with_file("./onyx-lsp.ini", .Write) {
            io.stream_write(it, Onyx_Lsp_Template_File);
        }

        return;
    }

    if string.starts_with(args[0] |> string.as_str(), "--port") {
        _, port_str := string.bisect(args[0] |> string.as_str(), #char "=");
        port = ~~ conv.parse_int(port_str);
    }

    setup_jsonrpc();

    if port > 0 {
        // Create a TCP socket
        listen_socket := net.socket_create(.Inet, .Stream, .ANY)->unwrap();
        defer listen_socket->close();

        listen_socket->option(.ReuseAddress, true);

        listen_addr: net.SocketAddress;
        net.make_ipv4_address(&listen_addr, 0, ~~ port);
        listen_socket->bind(&listen_addr);

        log(.Info, tprintf("Listening on port {}", port));
        listen_socket->listen();

        comm_socket = listen_socket->accept()->unwrap().socket;
        defer comm_socket->close();

        comm_socket->option(.NonBlocking, true);

        comm_reader = io.reader_make(^comm_socket);
        comm_writer = io.writer_make(^comm_socket, 0);
    
    } else {
        // When a way to poll standard input is available,
        // this should be used and the `stdin = true` should
        // be removed.
        // runtime.fs.__enable_non_blocking_stdin();
        
        comm_reader = io.reader_make(^stdio.stream);
        comm_writer = stdio.print_writer;
    }

    lsp_logger = make_lsp_logger(&json_rpc_handler);
    context.logger = lsp_logger->as_logger();

    json_rpc_handler->set_output_callback(^comm_writer, (w: ^io.Writer, msg: str) => {
        io.write_format(w, "Content-Length: {}\r\n", msg.length);
        io.write(w, "\r\n");
        io.write(w, msg);
        __flush_stdio();
    });

    listen_loop();
}

Onyx_Lsp_Template_File :: """[lsp]
mode=project
onyxFiles=name_of_main_onyx_file
workingDir=.
"""

