use core
use json_rpc {
    Method,
    Context,
    Status,
    Notification
}

OnyxFile :: struct {
    uri: str;
    errors: [..] CompilationError;
    previously_had_errors: bool;
}

#local
known_files: [..] OnyxFile;


TextDocumentItem :: struct {
    textDocument: struct {
        uri: str;
        languageId: str;
    };
}

@Notification.{"textDocument/didOpen"}
(c: ^Context, item: ^TextDocumentItem) {
    // :Config ??
    if item.textDocument.languageId != "onyx" do return;

    if !array.contains(known_files, #(it.uri == item.textDocument.uri)) {
        known_files << .{ string.alloc_copy(item.textDocument.uri) };
    }
}

@Notification.{"textDocument/didClose"}
(c: ^Context, _: ^TextDocumentItem) {
}


Position :: struct {
    line: u32;
    character: u32;
}

Diagnostic :: struct {
    range: struct {
        start: Position;
        end: Position;
    };

    message: str;

}

@Notification.{"textDocument/didChange"}
(c: ^Context, item: ^TextDocumentItem) {
    log(.Info, "Document changed, {}\n", item.textDocument.uri);
    // update_diagnostics(c);
}

@Notification.{"textDocument/didSave"}
(c: ^Context, item: ^TextDocumentItem) {
    log(.Info, "Document changed, {}\n", item.textDocument.uri);
    update_diagnostics(c, item.textDocument.uri);
}


update_diagnostics :: (c: ^Context, uri: str) {
    filename := do {
        if string.starts_with(uri, "file://") do return string.advance(uri, 7);
        return "";
    };

    errors := run_onyx_check(filename);
    defer delete(^errors);

    for ^known_files {
        if it.errors {
            it.previously_had_errors = true;
        }

        array.clear(^it.errors);
    }

    for err: errors {
        in_file := array.first(known_files, #(string.contains(it.uri, err.file)));
        if !in_file {
            known_files << .{ aprintf("file://{}", err.file) };
            in_file = array.first(known_files, #(string.contains(it.uri, err.file)));
        }

        in_file.errors << err;
    }

    for ^known_files {
        if !it.errors {
            if it.previously_had_errors {
                it.previously_had_errors = false;
                c->send_notification("textDocument/publishDiagnostics", ^.{ uri = it.uri, diagnostics = Diagnostic.[] });
            }

            continue;
        }

        diagnostics := make([..] Diagnostic);
        defer delete(^diagnostics);

        for^ err: it.errors {
            diagnostics << .{
                .{
                    .{ line = err.line - 1, character = err.column - 1 },
                    .{ line = err.line - 1, character = err.column },
                },
                err.msg
            };
        }

        c->send_notification("textDocument/publishDiagnostics", ^.{ uri = it.uri, diagnostics = diagnostics });
    }
}

CompilationError :: struct {
    file: str;
    line: u32;
    column: u32;
    msg: str;
}

// :Relocate
run_onyx_check :: (filename: str) -> [] CompilationError {
    // :Config
    args := array.make(.["check", "--no-colors"]);
    defer delete(^args);

    for string.split_iter(global_config.lsp.includeDirs, #char " ") {
        args << "-I";
        args << it;
    }

    switch global_config.lsp.mode {
        case "project" {
            for string.split_iter(global_config.lsp.onyxFiles, #char " ") {
                args << it;
            }
        }

        case "file" {
            args << filename;
        }
    }

    proc := os.process_spawn("onyx", args, starting_directory=global_config.lsp.workingDir);

    r := io.reader_make(^proc);
    output := r->read_all();

    original_output := output;
    defer if original_output do delete(^original_output);

    errors := make([..] CompilationError);

    if os.process_wait(^proc) == .Success {
        return errors;
    }

    while output {
        line, output' := string.bisect(output, #char "\n");

        if string.starts_with(line, "(") {
            string.advance(^line, 1);
            filename := string.temp_copy(string.read_until(^line, #char ":"));

            string.advance(^line, 1);
            line_number := conv.parse_int(^line);

            string.advance(^line, 1);
            col := conv.parse_int(^line);

            string.advance(^line, 2);
            msg := string.temp_copy(string.strip_whitespace(line));

            errors << .{
                filename, ~~line_number, ~~col, msg
            };
        }
    }
    
    return errors;
}

